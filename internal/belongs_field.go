package internal

import (
	"errors"
	"fmt"
	"github.com/c9s/inflect"
	"reflect"
)

var errInvalidBelongsToType = errors.New("invalid belongsTo field type. for a belongsToMany relation, use many2many")

type belongsToField struct {
	*relationField

	joinJsonapiFields []reflect.StructField
	joinPGFields      []reflect.StructField

	// whether the id field was
	// changed to a pointer type
	idFieldPointer bool
}

func newBelongsToField(r SchemaRegistry, schema *Schema, f *reflect.StructField) SchemaField {
	base := newRelationField(r, schema, f)

	if base.collection {
		panic(errInvalidBelongsToType)
	}

	field := &belongsToField{
		relationField: base,
	}

	// TODO: fail if there are invalid struct tag options

	return field
}

func (f *belongsToField) ColumnName() string {
	return f.relationIdFieldColumn()
}

func (f *belongsToField) PGFilterColumn() string {
	// the column name for the relation id field generated by go-pg
	// is a snake_cased version of the id field name
	return fmt.Sprintf("%s.%s", f.schema.alias, f.relationIdFieldColumn())
}

// override this function to calculate topLevel pg fields on demand,
// i.e. after non-top-level pg fields were calculated for reference.
func (f *belongsToField) pgFields() []reflect.StructField {
	if f.pgF != nil {
		return f.pgF
	}

	f.pgF = f.pgBelongsToFields(false)
	return f.pgF
}

func (f *belongsToField) pgJoinFields() []reflect.StructField {
	if f.joinPGFields != nil {
		return f.joinPGFields
	}

	f.joinPGFields = f.pgBelongsToFields(true)
	return f.joinPGFields
}

// generates the pg fields for a belongsTo relation. Example:
// Owner *User `jargo:",has"
// =>
// OwnerId int64 // join model and full model
// Owner *User   // full model only
func (f *belongsToField) pgBelongsToFields(joinField bool) []reflect.StructField {
	// every belongsTo association has a column containing
	// the id of the related resource

	typ := f.relationIdFieldType()
	// if the relation is nullable,
	// ensure the id type is a pointer type
	if typ.Kind() != reflect.Ptr && f.nullable {
		typ = reflect.New(typ).Type()
		f.idFieldPointer = true
	}

	tag := fmt.Sprintf(`sql:"%s`, f.relationIdFieldColumn())
	if !f.nullable {
		tag += ",notnull"
	}
	if f.sqlUnique {
		tag += ",unique"
	}

	if isUUIDField(typ) {
		// the sql type must match the
		// id field's sql type
		tag += ",type:uuid"
	}
	tag += `"`

	idField := reflect.StructField{
		Name: f.relationIdFieldName(),
		Type: typ,
		Tag:  reflect.StructTag(tag),
	}
	fields := []reflect.StructField{idField}

	if !joinField {
		// non-join fields contain a reference
		// to the full pg model of the relation,
		// so relation data can be fetched in queries
		field := reflect.StructField{
			Name: f.fieldName,
			Type: f.relationJoinPGFieldType(),
		}
		fields = append(fields, field)
	}

	return fields
}

// relationIdFieldType returns the type of the relation's id field.
func (f *belongsToField) relationIdFieldType() reflect.Type {
	var schema *Schema
	if f.schema.resourceModelType == f.relationType {
		// if the related resource is of the same type
		// as the resource being registered right now,
		// it's not registered in the registry yet.
		// therefore, get schema from field itself.
		schema = f.schema
	} else {
		// ensure relation schema is registered
		var err error
		schema, err = f.registry.RegisterSchema(f.relationType)
		if err != nil {
			panic(err)
		}
	}
	return schema.IdField().typ()
}

// relationIdFieldName returns the name of the foreign id field.
func (f *belongsToField) relationIdFieldName() string {
	return fmt.Sprintf("%sId", f.fieldName)
}

// relationIdFieldColumn returns the sql column name of the foreign id field.
func (f *belongsToField) relationIdFieldColumn() string {
	return inflect.Underscore(f.relationIdFieldName())
}

func (f *belongsToField) createInstance() schemaFieldInstance {
	return &belongsToFieldInstance{
		relationFieldInstance: f.relationField.createInstance(),
		field: f,
	}
}

type belongsToFieldInstance struct {
	*relationFieldInstance
	field *belongsToField
}

func (i *belongsToFieldInstance) parentField() SchemaField {
	return i.field
}

func (i *belongsToFieldInstance) sortValue() interface{} {
	val := i.values[0]
	// relations may be nil
	if val == nil {
		return nil
	}

	// return relation's id value
	for _, f := range val.fields {
		if idf, ok := f.(*idFieldInstance); ok {
			return idf.sortValue()
		}
	}

	panic("could not find relation's id field")
}

// parsePGModel parses the value of the pg relation struct field
// (e.g. *User) and stores it in i.values[0].
// If the relation struct field is nil, but the relation id field (e.g. UserId)
// is not zero, stores a new instance of the relation type with the id field set
// in i.values[0].
func (i *belongsToFieldInstance) parsePGModel(source *pgModelInstance) {
	if i.field.schema != source.schema {
		panic(errMismatchingSchema)
	}
	i.values = nil
	// do not parse nil models
	if source.value.IsNil() {
		return
	}

	var schemaInstance *SchemaInstance
	pgModelInstance := source.value.Elem().FieldByName(i.field.fieldName).Interface()
	schemaInstance = i.relationSchema.parseJoinPGModel(pgModelInstance)

	// if relation struct field is nil, but id field isn't,
	// create a new instance of the model and set its id field
	if schemaInstance == nil {
		idField := source.value.Elem().FieldByName(i.field.relationIdFieldName())

		// if the relation id field was converted to a pointer,
		// dereference it to be able to assign it to
		// the target model's id field.
		if i.field.idFieldPointer {
			idField = idField.Elem()
		}

		if idField.IsValid() {
			id := idField.Interface()
			schemaInstance = i.relationSchema.createInstance()
			// set id field
			for _, f := range schemaInstance.fields {
				if idField, ok := f.(*idFieldInstance); ok {
					idField.value = id
				}
			}
		}
	}

	i.values = []*SchemaInstance{schemaInstance}
}

// sets the value of the pg relation id field (e.g. UserId) to the id value
// of the Schema instance stored in i.values[0]
func (i *belongsToFieldInstance) applyToPGModel(target *pgModelInstance) {
	if i.field.schema != target.schema {
		panic(errMismatchingSchema)
	}
	id, ok := i.relationId()
	if !ok {
		return
	}
	// set value of target's relation id field (UserId)
	i.applyIdValueToPGModel(target.value, id)
	// set value of target's relation model field (User)
	target.value.Elem().FieldByName(i.field.fieldName).Set(reflect.ValueOf(i.values[0].toJoinPGModel()))
}

func (i *belongsToFieldInstance) parseJoinPGModel(source *joinPGModelInstance) {
	if i.field.schema != source.schema {
		panic(errMismatchingSchema)
	}
	i.values = nil
	// do not parse nil models
	if source.value.IsNil() {
		return
	}

	// parse the pg model's relation id field (UserId)
	idValue := source.value.Elem().FieldByName(i.field.relationIdFieldName())
	if i.field.idFieldPointer {
		idValue = idValue.Elem()
	}
	// if it's a nil pointer, return
	if !idValue.IsValid() {
		return
	}

	// create an instance of the relation schema and set the id value
	relationInstance := i.relationSchema.createInstance()
	for _, f := range relationInstance.fields {
		if idField, ok := f.(*idFieldInstance); ok {
			idField.value = idValue.Interface()
		}
	}

	// store the relation instance in values[0]
	i.values = []*SchemaInstance{relationInstance}
}

func (i *belongsToFieldInstance) applyToJoinPGModel(target *joinPGModelInstance) {
	if i.field.schema != target.schema {
		panic(errMismatchingSchema)
	}

	id, ok := i.relationId()
	if !ok {
		return
	}
	// set value of target's relation id field (UserId)
	i.applyIdValueToPGModel(target.value, id)
}

func (i *belongsToFieldInstance) applyToJoinResourceModel(source *resourceModelInstance) {
	if i.field.schema != source.schema {
		panic(errMismatchingSchema)
	}
	if len(i.values) == 0 {
		return
	}

	v := i.values[0]
	// relations may be nil
	if v == nil {
		return
	}

	rmi := v.toJoinResourceModel()

	// if target field is not nullable,
	// dereference value pointer
	val := reflect.ValueOf(rmi)
	if !isNullable(i.field.fieldType) {
		val = val.Elem()
	}
	source.value.Elem().FieldByName(i.field.fieldName).Set(val)
}

// relationId returns the id value of the relation,
// extracting it from the relation model.
func (i *belongsToFieldInstance) relationId() (interface{}, bool) {
	if len(i.values) == 0 {
		return nil, false
	}

	// extract id field from relation
	v := i.values[0]
	// relations may be nil
	if v == nil {
		return nil, false
	}

	var id interface{}
	for _, f := range v.fields {
		if idField, ok := f.(*idFieldInstance); ok {
			id = idField.value
		}
	}
	if id == nil {
		panic(errors.New("id field of related resource not found"))
	}
	return id, true
}

// applyIdValueToPGModel sets the target pgModelInstance
// or joinPgModelInstance's id field (UserId) to the value of id.
func (i *belongsToFieldInstance) applyIdValueToPGModel(value *reflect.Value, id interface{}) {
	// set value of relation id field (UserId)
	idField := value.Elem().FieldByName(i.field.relationIdFieldName())

	if i.field.idFieldPointer {
		// get pointer to id value,
		// as relation id field is a pointer type
		idValue := reflect.New(reflect.TypeOf(id))
		idValue.Elem().Set(reflect.ValueOf(id))

		idField.Set(idValue)
	} else {
		idField.Set(reflect.ValueOf(id))
	}
}
