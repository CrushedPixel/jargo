package internal

import (
	"reflect"
	"fmt"
)

const (
	primaryFieldJsonapiName = "id"
	primaryFieldColumn      = "id"
)

var primaryFieldType = reflect.TypeOf(int64(0))

// generates all fields that are always required to describe a resource via jsonapi,
// currently only the Id field
func generateStaticJsonapiFields(d *resourceDefinition) []reflect.StructField {
	// generate internal field marking struct type
	// as jsonapi model generated by jargo
	internalField := reflect.StructField{
		Name: jsonapiModelField,
		Type: reflect.TypeOf(new(interface{})),
	}

	for _, f := range d.fields {
		if f.typ != id {
			continue
		}

		tag := fmt.Sprintf(`jsonapi:"primary,%s"`, d.name)

		sf := reflect.StructField{
			Name: f.structField.Name,
			Type: f.structField.Type,
			Tag:  reflect.StructTag(tag),
		}

		return []reflect.StructField{internalField, sf}
	}

	panic("could not find id field")
}

// generates the struct fields required to describe an attribute field via jsonapi
func generateJsonapiFields(f *fieldDefinition, r *Registry) []reflect.StructField {
	if f.name == unexportedFieldName {
		return []reflect.StructField{}
	}

	sf := reflect.StructField{
		Name: f.structField.Name,
	}

	// determine field type
	var typ reflect.Type
	switch f.typ {
	case attribute:
		typ = f.structField.Type
	case has, belongsTo, many2many:
		collection := f.structField.Type.Kind() == reflect.Slice
		// get relation from registry to get relation's joinPGModel
		res, err := r.getResource(getStructType(f.structField.Type))
		if err != nil {
			panic(err)
		}
		typ = reflect.PtrTo(res.joinJsonapiModel)
		if collection {
			typ = reflect.SliceOf(typ)
		}
	}
	sf.Type = typ

	// generate field tag
	tag := `jsonapi:"`
	switch f.typ {
	case attribute:
		tag += fmt.Sprintf(`attr,%s`, f.name)
	case has, belongsTo, many2many:
		tag += fmt.Sprintf(`relation,%s`, f.name)
	default:
		panic("can only generate jsonapi fields for member fields")
	}

	if f.jsonOmitempty {
		tag += `,omitempty`
	}

	tag += `"`

	sf.Tag = reflect.StructTag(tag)
	return []reflect.StructField{sf}
}

// generates all fields that are always required to describe a resource via go-pg,
// currently the TableName and Id field
func generateStaticPGFields(d *resourceDefinition) []reflect.StructField {
	// generate internal field marking struct type
	// as pg model generated by jargo
	internalField := reflect.StructField{
		Name: pgModelField,
		Type: reflect.TypeOf(new(interface{})),
		Tag:  reflect.StructTag(`sql:"-"`),
	}

	empty := new(struct{})
	tableNameField := reflect.StructField{
		Name: "TableName",
		Type: reflect.TypeOf(*empty),
		// quote table name and alias as go-pg doesn't do it for aliases
		Tag: reflect.StructTag(fmt.Sprintf(`sql:"\"%s\",alias:\"%s\""`, d.table, d.alias)),
	}

	fields := []reflect.StructField{internalField, tableNameField}

	for _, f := range d.fields {
		if f.typ != id {
			continue
		}

		sf := reflect.StructField{
			Name: f.structField.Name,
			Type: f.structField.Type,
			Tag:  reflect.StructTag(fmt.Sprintf(`sql:"%s,pk"`, primaryFieldColumn)),
		}

		return append(fields, sf)
	}

	panic("could not find id field")
}

func generateJoinPGFields(f *fieldDefinition) []reflect.StructField {
	fields := make([]reflect.StructField, 0)

	switch f.typ {
	case attribute:
		sf := reflect.StructField{
			Name: f.structField.Name,
			Type: f.structField.Type,
			Tag:  reflect.StructTag(fmt.Sprintf(`sql:"%s"`, f.column)),
		}
		fields = append(fields, sf)
	case belongsTo:
		sf := reflect.StructField{
			Name: fmt.Sprintf("%sId", f.structField.Name),
			Type: primaryFieldType,
		}
		fields = append(fields, sf)
	}

	return fields
}

// generates the struct field required to describe an attribute field via go-pg.
// for belongsTo relation fields, generates the id field for the foreign value.
func generatePGFields(f *fieldDefinition, r *Registry) []reflect.StructField {
	fields := make([]reflect.StructField, 0)

	sf := reflect.StructField{
		Name: f.structField.Name,
	}

	// determine field type
	var typ reflect.Type
	switch f.typ {
	case attribute:
		typ = f.structField.Type
	case has, belongsTo, many2many:
		collection := f.structField.Type.Kind() == reflect.Slice
		// get relation from registry to get relation's joinPGModel
		res, err := r.getResource(getStructType(f.structField.Type))
		if err != nil {
			panic(err)
		}
		typ = reflect.PtrTo(res.joinPGModel)
		if collection {
			typ = reflect.SliceOf(typ)
		}
	}
	sf.Type = typ

	// generate field tag
	var tag string
	switch f.typ {
	case attribute:
		tag = fmt.Sprintf(`sql:"%s`, f.column)

		if f.sqlNotnull {
			tag += ",notnull"
		}
		if f.sqlUnique {
			tag += ",unique"
		}
		if f.sqlDefault != "" {
			tag += fmt.Sprintf(",default:%s", f.sqlDefault)
		}

		tag += `"`
	case has:
		if f.pgFk != "" {
			tag = fmt.Sprintf(`pg:",fk:%s"`, f.pgFk)
		}
	case belongsTo:
		// generate id field for relation
		idField := reflect.StructField{
			Name: fmt.Sprintf("%sId", f.structField.Name),
			Type: primaryFieldType,
		}

		fields = append(fields, idField)
	case many2many:
		tag = fmt.Sprintf(`pg:",many2many:%s"`, f.pgJoinTable)
	default:
		panic("can only generate pg fields for member fields")
	}

	sf.Tag = reflect.StructTag(tag)
	return append(fields, sf)
}
